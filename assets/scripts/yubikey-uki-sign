#!/bin/bash
set -euo pipefail

# sleep 5

# --- Theme Configuration ---
CYAN='\033[1;36m'
GREEN='\033[1;32m'
RED='\033[1;31m'
BLUE='\033[1;34m'
YELLOW='\033[1;33m'
NC='\033[0m'
BOLD='\033[1m'

WORKING="${CYAN}»${NC}"
SUCCESS="${GREEN}✓${NC}"
ERROR="${RED}✗${NC}"
INFO="${BLUE}i${NC}"
WARN="${YELLOW}!${NC}"

# --- Global definitions ---
TMP_DIR=$(mktemp -d -t build-uki-XXXXXXXXXX)

# --- Cleanup Logic ---
cleanup() {
	local exit_code=$?
	if [ -d "$TMP_DIR" ]; then
		echo -e "${WORKING} Cleaning up temporary files..."
		rm -rf "$TMP_DIR"
	fi
	echo -e "${INFO}---Script complete---"
	exit $exit_code
}

# SET THE TRAP: Cleanup will run on exit, error, or interruption
trap cleanup EXIT SIGINT SIGTERM ERR

# --- Helper: Desktop Notifications ---
notify_user() {
	local USER_ID
	USER_ID=$(id -u "${SUDO_USER:-$(loginctl list-sessions | grep 'seat0' | awk '{print $3}')}")
	DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$USER_ID/bus" \
		notify-send -i "security-high" "UKI Signing" "$1" 2>/dev/null || echo "Notification failed"
}

# --- Paths ---
CERT="/etc/pki/akmods/certs/yubikey-db.der"
ESP_PATH="/boot/efi"
DEST_DIR="${ESP_PATH}/EFI/Linux"
STUB="/usr/lib/systemd/boot/efi/linuxx64.efi.stub"
BOOTLOADER_SRC="/usr/lib/systemd/boot/efi/systemd-bootx64.efi"
BOOTLOADER_DEST="${ESP_PATH}/EFI/BOOT/BOOTX64.EFI"
SYSTEMD_BOOTLOADER_DEST="${ESP_PATH}/EFI/systemd/systemd-bootx64.efi"

# Yubikey PIN
PIN=""

# Defaults
COMMIT_HASH=""
KERNEL_VERSION=""
BOOT_HASH=""
UKI_IMAGE=""
OUTPUT_DIR=""

# Get kernel cmdline
CMDLINE="$(cat /proc/cmdline | sed -e 's/BOOT_IMAGE=[^ ]* //g' | sed -e 's/ostree=[^ ]* //g')"

# --- Sign systemd bootloader ---
sign_bootloader() {
	echo -e "${WORKING} Preparing to sign and install systemd-boot..."
	cp "$BOOTLOADER_SRC" "${TMP_DIR}/bootx64.efi"

	notify_user "Action Required: Touch Yubikey to sign the Bootloader."
	systemctl restart pcscd && sleep 1

	PIN=$(systemd-ask-password "Enter Yubikey PIN for UKI signing:" --icon=security-high --timeout=300)

	if [ -z "$PIN" ]; then
		echo -e "${ERROR} No PIN entered or request timed out."
		return 1
	fi

	if env LD_PRELOAD=/usr/lib64/libpcsclite_real.so.1 SBCTL_YUBIKEY_PIN="$PIN" /usr/bin/sbctl sign -s "${TMP_DIR}/bootx64.efi"; then
		echo -e "${SUCCESS} Bootloader signed."
		# Use update first, fall back to install. TODO: correct these install commands. --boot-loader-src is not a valid flag
		# bootctl update --boot-loader-src="${TMP_DIR}/bootx64.efi" || bootctl install --boot-loader-src="${TMP_DIR}/bootx64.efi"
		cp -f "${TMP_DIR}/bootx64.efi" "$BOOTLOADER_DEST"
		cp -f "${TMP_DIR}/bootx64.efi" "$SYSTEMD_BOOTLOADER_DEST"
	else
		echo -e "${ERROR} Failed to sign bootloader."
		return 1
	fi
}

find_boot_hash() {
	local commit_hash="$1"

	local bhash=""

	# shellcheck disable=SC2010
	ostree_boot_path="$(ls -l /ostree/boot.1.1/default/*/* | grep "$commit_hash" | awk '{print $9}')"
	bhash="$(echo "$ostree_boot_path" | cut -d'/' -f5)"
	if [[ -z "$ostree_boot_path" || -z "$bhash" ]]; then
		echo -e "${ERROR} Unable to find boot path or hash for deployment: ${commit_hash}"
		return 1
	fi
	BOOT_HASH="$bhash"
}

# --- Build UKI ---
build_uki() {
	local commit_hash="$1"

	local ostree_boot_path=""
	local cmdline=""
	local kernel=""
	local initrd=""

	echo -e "${WORKING} Building UKI for kver=${BOLD}${KERNEL_VERSION}${NC} boot_hash=${BOLD}${BOOT_HASH}${NC}..."

	# shellcheck disable=SC2010
	ostree_boot_path="$(ls -l /ostree/boot.1.1/default/*/* | grep "$commit_hash" | awk '{print $9}')"
	cmdline="ostree=$ostree_boot_path $CMDLINE"
	kernel="${ostree_boot_path}/usr/lib/modules/${KERNEL_VERSION}/vmlinuz"
	initrd="${ostree_boot_path}/usr/lib/modules/${KERNEL_VERSION}/initramfs.img"

	ukify build \
		--linux "$kernel" \
		--initrd "$initrd" \
		--cmdline "$cmdline" \
		--os-release @"/etc/os-release" \
		--stub "$STUB" \
		--output "${OUTPUT_DIR}/$UKI_IMAGE"

	echo -e "${SUCCESS} UKI build success."
}

# --- Sign UKI with Yubikey ---
sign_uki() {
	echo -e "${WORKING} Signing UKI with sbctl..."
	notify_user "Action Required: Touch Yubikey to sign the UKI image."

	systemctl restart pcscd && sleep 1

	if [ -z "$PIN" ]; then
		PIN=$(systemd-ask-password "Enter Yubikey PIN for UKI signing:" --icon=security-high --timeout=300)
		if [ -z "$PIN" ]; then
			echo -e "${ERROR} No PIN entered or request timed out."
			return 1
		fi
	fi

	if env LD_PRELOAD=/usr/lib64/libpcsclite_real.so.1 SBCTL_YUBIKEY_PIN="$PIN" /usr/bin/sbctl sign -s "${OUTPUT_DIR}/${UKI_IMAGE}"; then
		echo -e "${SUCCESS} UKI signed successfully."
	else
		echo -e "${ERROR} UKI signing failed."
		return 1
	fi
	sbverify --cert "$CERT" "${OUTPUT_DIR}/${UKI_IMAGE}"
}

# --- Deploy ---
deploy_uki() {
	echo -e "${WORKING} Deploying to ESP..."
	mkdir -p "$DEST_DIR"
	cp "${OUTPUT_DIR}/${UKI_IMAGE}" "$DEST_DIR/$UKI_IMAGE"
}

# --- Cleanup Old Files ---
cleanup_old_uki() {
	local old_files=""

	echo -e "${WORKING} Cleaning up old UKIs..."
	CURRENT_V=$(uname -r)
	# shellcheck disable=SC2010
	old_files=$(ls "${DEST_DIR}"/bazzite-*.efi 2>/dev/null | grep -v "$KERNEL_VERSION" | grep -v "$CURRENT_V" | sort -V | head -n -2 || true)

	if [[ -n "$old_files" ]]; then
		echo "$old_files" | while read -r file; do
			echo -e "  ${RED}✖ Removing:${NC} $(basename "$file")"
			rm -f "$file"
		done
		echo -e "${SUCCESS} Cleanup complete."
	fi
}

is_command() {
    case "$1" in
        build|sign|deploy) return 0 ;;
        *) return 1 ;;
    esac
}


echo -e "${INFO}---Script start---"

declare -a COMMANDS=()

# Parse args
while [[ $# -gt 0 ]]; do
	case "$1" in
	-c|--commit)
		COMMIT_HASH="$2"
		shift 2
		;;
	-k|--kver)
		KERNEL_VERSION="$2"
		shift 2
		;;
	-o|--outdir)
		OUTPUT_DIR="$2"
		shift 2
		;;
	*)
		COMMANDS+=("$1")
		shift 1
		;;
	esac
done

[[ -z "$COMMIT_HASH" ]] && echo -e "${ERROR} Missing commit hash [-c]" && exit 1
[[ -z "$KERNEL_VERSION" ]] && KERNEL_VERSION="$(uname -r)" && echo -e "${WARN} Missing kernel version [-k]. Using running kernel $KERNEL_VERSION"
[[ -z "$OUTPUT_DIR" ]] && OUTPUT_DIR="$TMP_DIR"

[[ ${#COMMANDS[@]} -eq 0 ]] && echo -e "${ERROR} Missing command(s)" && exit 1

# Find boot hash so we can derive UKI IMAGE file name
find_boot_hash "$COMMIT_HASH"
[[ -z "$BOOT_HASH" ]] && echo -e "${ERROR} Unable to find boot files. Boot hash missing." && exit 1

UKI_IMAGE="deimos-${KERNEL_VERSION}-${BOOT_HASH}.efi"

echo -e "${INFO} BOOT-HASH: $BOOT_HASH"
echo -e "${INFO} UKI-IMAGE: $UKI_IMAGE"

while [[ ${#COMMANDS[@]} -gt 0 ]]; do
    CMD="${COMMANDS[0]}"
    
	case $CMD in
	build)
		build_uki "$COMMIT_HASH"
		cp "${OUTPUT_DIR}/$UKI_IMAGE" "$(pwd)/"
		;;

	sign)
		sign_uki
		;;

	deploy)
		deploy_uki
		;;

	*)
		echo -e "${ERROR} unknown command $CMD"
		exit 1
		;;
	esac
	COMMANDS=("${COMMANDS[@]:1}")
done

echo -e "${WORKING} Checking bootloader integrity..."
NEEDS_BOOTLOADER_SIGN=false
if [[ ! -f "$BOOTLOADER_DEST" ]]; then
	NEEDS_BOOTLOADER_SIGN=true
elif ! sbverify --cert "$CERT" "$BOOTLOADER_DEST" &>/dev/null; then
	echo -e "${INFO} Installed bootloader is unsigned or signature invalid."
	NEEDS_BOOTLOADER_SIGN=true
elif [[ "${1-}" == "--sign-bootloader" ]]; then
	NEEDS_BOOTLOADER_SIGN=true
	shift
fi

if [[ "$NEEDS_BOOTLOADER_SIGN" == "true" ]]; then
	sign_bootloader
else
	echo -e "${SUCCESS} Bootloader is already signed and valid."
fi
